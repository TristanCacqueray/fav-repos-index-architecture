# -*- org-confirm-babel-evaluate: 'nil ; -*-
#+title:  Favorite Repository Index
#+subtitle: A distributed service architecture powered by nix and gRPC-haskell
#+author: Tristan de Cacqueray
#+date:   2021-04-24

* tl;dr
:PROPERTIES:
:CUSTOM_ID: tldr
:END:

This project implements a simple service named Favorite Repository Index (FRI).

The goal is to implement an incremental roadmap using architectural decision records ([[https://adr.github.io][ADR]]).

#+begin_src plantuml :file doc/architecture.png :eval yes
  title FRI architecture

  package "backend" {
    database "database" as Datastore
    collections "fri-api" as Api
    collections "fri-worker" as Worker
    cloud proxy as Proxy
  }
  actor user as User

  Api --> Datastore
  Api <--> Worker
  Proxy -> Api
  User --> Proxy
#+end_src

#+begin_src plantuml :file doc/sequence.png :eval yes
title FRI workflow
actor user as User
participant "fri-api" as Api
participant "fri-worker" as Worker
entity "GitHub"  as GH
database "database" as Db

User -> Api    : send github username
Api -> GH      : request favorites repos
User <- Api    : stream repos information
Api -> Db      : index repos
...
User -> Api    : send full text search
Api -> Db      : query index
User <- Api    : get result
...
Worker -> Api  : request last timestamp
Worker -> GH   : get repo updates
Worker -> Api  : send updates
Api -> Db      : index updates
#+end_src

* Motivation
:PROPERTIES:
:CUSTOM_ID: motivation
:END:

I introduced a purely functional and strongly typed component, named [[https://github.com/change-metrics/lentille][Lentille]], while working on adding task datas to the [[https://github.com/change-metrics/monocle][Monocle]] service.
I used Lentille to showcase a practical application of the Haskell language: performing data processing of the bugzilla API.
Then, I investigated how one could leverage this approach for the rest of the service, in particular, the web api and client which are written in Python and Javascript.

So my idea was to use an IDL such as OpenAPI or Protobuf to implement the next features while keeping the existing code in place.
Before working around the existing code base, I wanted to investigate using Haskell and gRPC in a greenfield project first.

I'm pretty satisfied with the result, and I'm eager to share my approach with you!

* The Challenge
:PROPERTIES:
:CUSTOM_ID: challenge
:END:

TODO: define the goal and challenge of monocle

* Roadmap
:PROPERTIES:
:CUSTOM_ID: roadmap
:END:

TODO: map roadmap to commits

** Packages Management
:PROPERTIES:
:CUSTOM_ID: packages-management
:END:

#+begin_src markdown
# Choice of package manager

## Context and Problem Statement

We need to install and configure external dependencies to build and operate the service.
We also needs a workflow to build and distribute the service application.

## Considered Options

- RPM package
- Container image
- Ansible role
- Nix expression

## Decision Outcome

Chosen option: "Nix expression", because it comes out best (see below).

### Positive Consequences

- Reproducible, by pinning the dependencies we control the entire stack.
- Mature ecosystem, nixpkgs features many packages.
- Enable efficient distribution.

### Negative Consequences

- Require an extra language.
- Nix introduces new issues.

## Pros and Cons of the Options

### RPM package

- Good, because it is battle tested.
- Good, because it respects the Linux Filesystem Hierarchy Standard (FHS).
- Good, because it has strong community support.
- Bad, because it requires energy to manage dependencies.

### Container image

- Good, because it is popular.
- Bad, because it is inefficient and tedious to work with.

### Ansible roles

- Good, because it is simple.
- Bad, because it is hard to make it idempotent or reproducable.

## Nix expression

- Good, because it is programable.
- Bad, because the language is hard to use.
#+end_src

- A shell environment with development tools installed:

#+begin_src
$ nix-shell --pure
[nix-shell]$ which strace
/nix/store/6yf85zvdchma8khwa7gl4ng6h3b4yr9n-strace-5.11/bin/strace
#+end_src

- A derivation to start a service:

#+begin_src
$ $(nix-build --attr db.start)
Starting the database...
#+end_src

** Database
:PROPERTIES:
:CUSTOM_ID: database
:END:
#+begin_src markdown
ADR: https://github.com/change-metrics/monocle/blob/master/doc/adr/0002-choice-of-elasticsearch.md
#+end_src

- elasticsearch service deployment:

#+begin_src
$ elk-start
Starting the database...

$ curl localhost:9242
{ "name": "fri", ..., "tagline" : "You Know, for Search"}

$ elk-stop
Stoping the database...

$ elk-destroy
Deleting the database...
#+end_src

** Interfaces Definition
:PROPERTIES:
:CUSTOM_ID: interfaces-definition
:END:

#+begin_src markdown
ADR: https://github.com/change-metrics/monocle/issues/346
#+end_src

- protobuf definitions of the api: [[./protos/fri.proto][fri.proto]]

- haskell, javascript and python code generation:

#+begin_src
$ protobuf-codegen
Haskell bindings:
compile-proto-file --proto protos/fri.proto --out src/

Python bindings:
python3 -m grpc_tools.protoc -Iprotos --python_out=python/ --grpc_python_out=python/ fri.proto

Javascript bindings:
protoc -I=protos fri.proto --js_out=import_style=commonjs:javascript/src/ --grpc-web_out=import_style=commonjs,mode=grpcwebtext:javascript/src/
#+end_src

** Api Service
:PROPERTIES:
:CUSTOM_ID: api-structure
:END:

#+begin_src markdown
ADR: https://github.com/change-metrics/lentille/blob/main/doc/adr/0002-choice-of-language.md
#+end_src

- A package set with relude version 1.0:

#+begin_src
$ nix-shell --pure --command "ghc-pkg list relude"
    relude-1.0.0.1
#+end_Src

- A REPL:

#+begin_src
$ cabal repl -O0
Ok, five modules loaded.
λ> import Api
λ> :type Api.run
Api.run :: Int -> IO ()
#+end_src

- A CLI to start the service

#+begin_src
$ cabal run fri-api -- --elk-url localhost:9242 --port 8042
fri-api running on :8042
#+end_src

** GitHub Queries
:PROPERTIES:
:CUSTOM_ID: github-queries
:END:

- A haskell module to define crawler function [[./src/FriGitHub.hs][FriGitHub]]:

#+begin_src haskell
getFavorites :: MonadIO m => UserName -> m [Repo]
#+end_src

- REPL tutorial:

#+begin_src haskell
λ> FriGitHub.getFavorites "TristanCacqueray"
[ Repo {repoName = "haskellfoundation/matchmaker", repoTopic = [], repoDescription = "Find your open-soulmate <\128156>"}
, Repo {repoName = "Gabriel439/grace", repoTopic = [], repoDescription = "A ready-to-fork interpreted, typed, and functional language"}
, ...]
#+end_src


** Database Queries
:PROPERTIES:
:CUSTOM_ID: database-queries
:END:

- TODO: A document mapping

- TODO: A haskell module to define repositories index and search function:

#+begin_src haskell
indexRepos :: MonadBH m => [Repo] -> m ()
searchRepos :: MonadBH m => Username -> m [Repo]
#+end_src

- REPL tutorial:

#+begin_src haskell
λ> TODO
#+end_src

** Client API
:PROPERTIES:
:CUSTOM_ID: client-api
:END:

- TODO: API implementation

- REPL tutorial:
#+begin_src haskell
λ> TODO
#+end_src

** Proxy
:PROPERTIES:
:CUSTOM_ID: proxy
:END:

#+begin_src markdown
ADR: https://github.com/change-metrics/monocle/issues/345
#+end_src

- envoy service deployment:

#+begin_src
$ envoy -c conf/envoy.yaml
starting main dispatch loop
#+end_src

** User Interface
:PROPERTIES:
:CUSTOM_ID: user-interface
:END:

- Live development server:

#+begin_src
$ cd javascript; pnpm start
> react-scripts start
#+end_Src

** Left Over
:PROPERTIES:
:CUSTOM_ID: left-over
:END:
- Authentication (openid, jwt, ...).
- Standalone cli (compose service function in a TUI).
- Distribution (container, vm, ansible, ...).
- Service auto scaling.
- CI with cachix.
